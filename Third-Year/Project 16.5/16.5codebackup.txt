\documentclass{article}
\usepackage{float}
\usepackage{enumitem}
\usepackage{hyperref}
\usepackage[margin=1in]{geometry}
\usepackage[framed, numbered]{matlab-prettifier}
\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage{multirow}
\hypersetup{
    colorlinks,
    citecolor=black,
    filecolor=black,
    linkcolor=black,
    urlcolor=black
}
\usepackage{graphicx}
\graphicspath{ {./Images/} }
\begin{document}
\title{Permutation Groups}
\maketitle
\tableofcontents
\newpage
\section*{Preface}
This is my CATAM project,  16.5 for part II. The code for each question can be found in section $N$.
\newpage
\section{Permutations}
\subsection{Question 1}
See below tables for outputs of my programs to calculate the inverse and product of permutations of $\{1,\ldots,n\}. $ In particular I have ran the program for $n=4$. The complexity of the program to calculate inverses is $O(n^2)$ while the complexity of the program to calculate products is $O(n)$.

\section{Groups}
\subsection{Question 2}
Let $\tilde G$ denote the group generated by the permutations outputted by the Stripping Algorithm of Sims.  Firstly we have $\tilde G\leq G$ since all elements in $\tilde G$ are generated by elements in $G$.  Then given any $g\in G$,  there must exist $g_1,\ldots g_l\in \tilde G$ such that 
\[ g_l^{-1}\cdots g_1^{-1}g=e\text{ or } g'\in \tilde G.\]
In either case we have $g$ is equal to a product of elements in $\tilde G$ and so itself is in $\tilde G$.  Hence we have $G=\tilde G$.

Given $G=\langle g_1,\ldots ,g_k\rangle$,  we must have $|\tilde G|\le k$. This is because at most each $g_k$ corresponds to a single element in $\tilde G$.  The complexity of the algorithm is $O(n^5$).
\subsection{Question 3}
See below a table of outputs for the Stripping Algorithm of Sims program, specifically for $n=4$.

\section{Orbit and Stabililzer}
\subsection{Question 4}
 For $G$ acting on a set $\Omega$ and $\alpha\in \Omega$,  there is a bijection between $G/G_\alpha$ and $G\alpha$ as follows
\begin{align*}
	G/G_\alpha &\to G\alpha \\
	gG\alpha &\mapsto g\alpha
\end{align*} 
The orbit stabiliser theorem is the above statement.  For finite groups there is a corollary of this theorem which is often referred to as the Orbit-Stabiliser Theorem.  Under the same set-up as the previously given bijection,  this corollary states
\[ |G\alpha|=\frac{|G|}{|G_\alpha|}.\]

\subsection{Question 5}
See below for a table of my program which calculates the orbit of an element, along with corresponding witnesses, under the action of permutation group. In particular I have ran the program for $n=5$. \\\\


Let $G=\langle g_1, \ldots ,g_k\rangle$.  My program works by noting that any element in the orbit of $\alpha$ will be given by a finite combination of $g_i$ applied $\alpha$ in some order.  Hence by calculating the image of $\alpha$ under each $g_i$ and recording some $g_i$ gives rise to each image, then iterating that process for each new element in the image will give us the orbit of $x$ along with witnesses. Further the program will terminate as by finiteness of $\Omega$,  the set $G$ acts on,  we will eventually reach every element in the orbit.  In which case applying each $g_i$ to this set will give us no new elements and so the program will terminate. 
\section{Schreier's Theorem and the Final Algorithm}
\subsection{Question 6}
Note that by the definition of $t_i$ we have
\begin{align*}
		t_1G_\alpha & =G_\alpha\\
		t_{i+1}G_\alpha & = y_it_iG_\alpha .
\end{align*}
Hence we have
\begin{align*}
		t_{r+1}G_\alpha & =y_r\cdots y_1t_1G_\alpha\\
								 & = xt_1G_\alpha \\
								 & = G_\alpha. \\
\end{align*}
Further, we have $t_{r+1}\in \text{im}(\varphi)=T$ and so $t_{r+1}=t_1$. Then for any $x\in G_\alpha$ we have
\begin{align*}
		x &= y_r\cdots y_1\\
		   &= t_{r+1}\big(t_{r+1}^{-1}y_rt_r\big)\cdots \big(t_2^{-1}y_1t_{1}\big)t_1^{-1}\\
		   &= t_{1}\big(\varphi(y_rt_r)^{-1}y_rt_r\big)\cdots \big(\varphi(y_1t_1)^{-1}y_1t_1\big)t_1^{-1}.		   
\end{align*}
Letting $\Lambda=\big\langle \varphi(yt)^{-1}yt: y\in Y, t\in T\big\rangle$ and applying this to $x=t_1$ gives $t_1\in \Lambda $. 
Hence for any $x\in G_\alpha$ we have 
\[x\in t_1 \Lambda t_1^{-1}\subset  \Lambda .\]
It follows that $G_\alpha\subset  \Lambda$. Then $(\forall y\in Y)(\forall t\in T)$ we have
\begin{align*}
				 \varphi(yt)G_\alpha& =ytG_\alpha\\
					\Rightarrow \varphi(yt)^{-1}yt &\in G_\alpha.
\end{align*}
Then the reverse inclusion follows and we must have $G_\alpha= \Lambda$. 
\subsection{Question 7}
If we didn't run the stripping algorithm at every stage in our program,  the efficiency of the program would be greatly reduced. This is because at each stage we would (in most cases) be increasing our number of generators for the group. This would then lead to an increase in time to calculate the orbit and witnesses.  This would then further increase the time to calculate the stabiliser and further the number of generators of the stabiliser. This would then spill over into the next repeat of the algorithm, exponentially increasing the number of calculations and storage required for the program to run.  For $n=20$ this would be a massive increase in time to run the program.  \\\\

\subsection{Question 8}
From IA, we know that $S_n=\langle (1\ 2),(1\ 2\ \ldots\ n)\rangle$, hence for all $n$ we must have $P_n>0$. Further note that $A_n\leq S_n$ and 
\[|A_n|=\frac{|S_n|}2,\]
so the probability of choosing two elements at random from $A_n$ is $\frac{1}4$,  hence  we have for all $n$ that $P_n\leq\frac{3}4$. Since if we choose both elements from $A_n$ then the subgroup the generate is contained in $A_n$ which is strictly contained in $S_n$.\\\\

Since $S_2=C_2$,  $P_2=\frac{3}{4}.$ Then for $n=3$ we have that

\end{document}